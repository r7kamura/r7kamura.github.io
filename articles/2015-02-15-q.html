<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width">
  <title>Slackの会話を元に一句詠む</title>
  <link href="/articles/2015-02-15-q" rel="canonical">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="search" type="application/opensearchdescription+xml" title="r7kamura.com" href="/opensearch.xml">
  <link rel="alternate" type="application/rss+xml" href="/feed.xml">
  <meta property="og:type" content="article">
  <meta property="og:title" content="Slackの会話を元に一句詠む">
  <meta property="og:url" content="https://r7kamura.com&#x2F;articles&#x2F;2015-02-15-q">
  <meta property="twitter:card" content="summary">
  <meta property="twitter:title" content="Slackの会話を元に一句詠む">
</head>
<body>
  <header>
    <nav>
      <a href="/">トップページ</a>
      <ul>
        <li>
          <a href="/articles">記事</a>
        </li>
        <li>
          <a href="https://google.com/search?q=site:r7kamura.com">検索</a>
        </li>
      </ul>
    </nav>
  </header>
  <main>
    <article>
  <h1>Slackの会話を元に一句詠む</h1>
  <footer>
    <p>
      <time datetime="2015-02-15T00:00:00+09:00">2015年02月15日</time>
    </p>
  </footer>
  <div>
    <p>SlackでBotに一句詠ませるために、<a href="https://github.com/r7kamura/ikku">r7kamura/ikku</a>という一句抽出ライブラリと、これを利用した<a href="https://github.com/r7kamura/ruboty-kokodeikku">r7kamura/ruboty-kokodeikku</a>という<a href="%5Br7kamura/ruboty%5D(https://github.com/r7kamura/ruboty)">Ruboty</a>用プラグインをつくりました。</p>
<h2 id="様子">様子</h2>
<p>このようにチャット上にBotを置いておくと、会話に反応して一句詠んでくれます。</p>
<p><img src="https://qiita-image-store.s3.amazonaws.com/0/4365/40659382-73a6-1509-216c-4409bc4d0f21.png" alt="image"></p>
<h2 id="ruboty-kokodeikku">ruboty-kokodeikku</h2>
<p>ruboty-kokodeikkuは、チャットBot用のフレームワークであるRubotyのためのプラグインです。Botが参加している部屋の全ての発言を監視し、一句として妥当なパターンがあれば一句詠んでくれます。</p>
<p><img src="https://qiita-image-store.s3.amazonaws.com/0/4365/291d7ecd-4cdf-5e5e-0ebb-58c16db07875.png" alt="image"></p>
<h3 id="使い方">使い方</h3>
<p>使い方は、mecabを使えるようにしてruboty-kokodeikkuをGemfileに追加するとOKです。Herokuで利用する場合は、以下のように環境変数を設定すると良いでしょう。</p>
<pre><code>heroku config:set \
  BUILDPACK_URL=https://github.com/diasks2/heroku-buildpack-mecab.git\
  LD_LIBRARY_PATH=/app/vendor/mecab/lib\
  MECAB_PATH=/app/vendor/mecab/lib/libmecab.so</code></pre><p><a href="http://qiita.com/sunny4381/items/10d30a8d5eeaae14a62d">Heroku buildpack: linuxbrew - Qiita</a>を参考にheroku-buildpack-multiを利用して上手くMeCabを入れたかったのですが、上手くいかなかったので今回は<a href="https://github.com/diasks2/heroku-buildpack-mecab">heroku-buildpack-mecab</a>を利用してMeCabを使えるようにしました。Ruboty自体の導入については<a href="http://qiita.com/r7kamura/items/8d1b98e28154de6030b9">Ruby製HubotクローンのRubotyをSlackで動かす - Qiita</a>を読むと良いでしょう。</p>
<h3 id="実装">実装</h3>
<p>Rubotyでは、Ruboty::Handlers::Baseを継承するクラスをつくると発言に反応できるようになり、<code>on</code> メソッドでパターンを登録できます。今回は全ての発言に反応して一句が詠めるかどうか調べたかったので、<code>//</code> を指定して全ての文字列に一致する正規表現を与え、更に <code>all: true</code> を指定してBOTにmentionを送らなくても反応するようにしました。</p>
<p>Rubotyは全てのプラグインをGemfileで管理するため、プラグインをつくるにはGemをつくる必要があります。最初は、簡単に試すため<a href="https://gist.github.com/r7kamura/529cab313a3bf792fcf9">GistにGemを置いていました</a>。詳しくは<a href="http://qiita.com/r7kamura/items/5e7d082d8e0d0471d71d">GistでGemを公開する - Qiita</a>に書いています。</p>
<pre><code class="language-rb">require &quot;ikku&quot;

module Ruboty
  module Handlers
    class Kokodeikku &lt; Base
      on(
        //,
        all: true,
        description: &quot;ここで一句&quot;,
        name: &quot;kokodeikku&quot;,
      )

      def kokodeikku(message)
        if !message.body.start_with?(&quot;ここで一句 &quot;) &amp;&amp; (phrases = reviewer.find(message.body))
          message.reply(&quot;ここで一句 #{phrases.map(&amp;:join).join(&#39; &#39;)}&quot;)
        end
      end

      private

      def reviewer
        @reviewer ||= Ikku::Reviewer.new
      end
    end
  end
end</code></pre>
<h2 id="ikkuの導入方法">Ikkuの導入方法</h2>
<p><a href="https://github.com/r7kamura/ikku">r7kamura/ikku</a>を使うための準備について説明します。</p>
<h3 id="mecab">MeCab</h3>
<p>Ikkuでは内部で[MeCab](<a href="http://ja.wikipedia.org/wiki/MeCab">MeCab - Wikipedia</a>)というオープンソースの形態素解析エンジンを利用しています。そのため、MeCabとその辞書データが利用できる環境になっている必要があります。MacでHomebrewを利用している場合には、以下のようにインストールできます。</p>
<pre><code>brew install mecab mecab-ipadic</code></pre><h3 id="ruby">Ruby</h3>
<p>IkkuはRubyを利用して記述しました。コード内でキーワード引数を利用したために、Ruby 2.0.0以上を必要とします。MeCabのRuby用ライブラリである<a href="https://bitbucket.org/buruzaemon/natto">Natto</a>を利用しています。MeCab RubyではなくNattoを利用したのは、インストールの難易度の低さを優先したためです。</p>
<h2 id="ikkuの使い方">Ikkuの使い方</h2>
<p><a href="https://github.com/r7kamura/ikku">r7kamura/ikku</a>のライブラリの使い方を説明します。</p>
<h3 id="ikkureviewernewrule-nil">Ikku::Reviewer.new(rule: nil)</h3>
<p>Ikkuの主なインターフェースは <code>Ikku::Reviewer</code> というクラスです。文字列から一句を抽出するなどの目的で利用する場合は、このクラスのインスタンスを生成し、メソッドを呼んで文字列を与えることになります。デフォルトでは五七五のパターンを一句として認識しますが、<code>rule: [4, 3, 5]</code> のように引数を与えることでこれを変更することもできます。</p>
<pre><code class="language-rb">reviewer = Ikku::Reviewer.new
reviewer = Ikku::Reviewer.new(rule: [5, 7, 5, 7])</code></pre>
<h3 id="ikkureviewerjudgetext">Ikku::Reviewer#judge(text)</h3>
<p>与えられた文字列が一句かどうかを判定し、trueまたはfalseを返すメソッドです。与えられた文字列中に一句が含まれているかどうかではなく、与えられた文字列全てを消費して一句詠めているかどうかを判定します。</p>
<pre><code class="language-rb">reviewer.judge(&quot;古池や蛙飛び込む水の音&quot;) #=&gt; true
reviewer.judge(&quot;ああ古池や蛙飛び込む水の音ああ&quot;) #=&gt; false</code></pre>
<h3 id="ikkureviewerfindtext">Ikku::Reviewer#find(text)</h3>
<p>与えられた文字列の中から一句を探し、最初に見つかったものを返します。見つからなかった場合はnilを返します。メソッド名をfindにしたのは <code>Enumerable#find</code> に倣ってのことです。ちなみにIkku::Reviewerは一句批評家です。</p>
<p>ここで返却される一句を表すオブジェクトは、複雑ですが、Ikku::Nodeのインスタンスの配列の配列です。例えば以下の例では、&quot;古池&quot;と&quot;や&quot;が五七五の最初の五を表す部分であり、二つのIkku::Nodeから構成されることを示しています。Ikku::Nodeにはインスタンスメソッドとして<code>to_s</code>が定義されているので、一句を表現するオブジェクトに <code>join</code> メソッドを呼ぶとひと繫ぎの文字列が得られます。</p>
<pre><code class="language-rb">reviewer.find(&quot;ああ古池や蛙飛び込む水の音ああ&quot;)
#=&gt; [[&quot;古池&quot;, &quot;や&quot;], [&quot;蛙&quot;, &quot;飛び込む&quot;], [&quot;水&quot;, &quot;の&quot;, &quot;音&quot;]]</code></pre>
<h3 id="ikkureviewersearchtext">Ikku::Reviewer#search(text)</h3>
<p>与えられた文字列の中に含まれる全ての一句を探し、それらの配列を返却します。findメソッドでは一つ見つかった瞬間に結果を返していましたが、このメソッドでは処理を継続して全ての一句の可能性を探索します。</p>
<pre><code class="language-rb">reviewer.search(&quot;ああ古池や蛙飛び込む水の音ああ天秤や京江戸かけて千代の春ああ&quot;)
#=&gt; [
#     [[&quot;古池&quot;, &quot;や&quot;], [&quot;蛙&quot;, &quot;飛び込む&quot;], [&quot;水&quot;, &quot;の&quot;, &quot;音&quot;]],
#     [[&quot;天秤&quot;, &quot;や&quot;], [&quot;京&quot;, &quot;江戸&quot;, &quot;かけ&quot;, &quot;て&quot;], [&quot;千代&quot;, &quot;の&quot;, &quot;春&quot;]]
#   ]</code></pre>
<h2 id="ikkuの仕組み">Ikkuの仕組み</h2>
<p>Ikkuの内部動作について説明します。</p>
<h3 id="ikkureviewer">Ikku::Reviewer</h3>
<p>一句レビュアーです。前に説明しました。Ikku::Parserを使って与えられた文字列をIkku::Nodeの配列に変換し、Ikku::Scannerを使って一句を探索します。</p>
<h3 id="ikkuparser">Ikku::Parser</h3>
<p>一句パーサーです。与えられた文字列を形態素解析エンジンにかけ、Ikku::Nodeの配列に変換します。MeCabで文字列を解析すると各形態素を表すNodeの配列が得られますが、Ikku::NodeはそれらのNodeをそれぞれ内包したものです。
言語パーサで言うところの字句解析器のような働きをします。コメント部分を表す字句が廃棄される言語処理系があるように、Ikku::Parserではこの段階で不要なノードを廃棄します。例えば、文頭や文末のようなメタ情報を表すノードは廃棄しています。</p>
<h3 id="ikkuscanner">Ikku::Scanner</h3>
<p>一句スキャナーです。与えられたIkku::Nodeの配列を先頭から消費していって、一句が成り立つかどうかを判定します。言語パーサで言うところの構文解析器のような働きをします。</p>
<p>必ず先頭から消費できなければ失敗で、例えば「ああ古池や蛙飛び込む水の音ああ」のような文字列が与えられた場合に、このScannerでの判定は失敗します。「古池や蛙飛び込む水の音ああ」を表すIkku::Nodeの配列が与えられなければいけないわけです。一句を抽出する際、Ikku::Reviewerでは、Parserから得られたIkku::Nodeの配列をもとに様々な組み合わせをつくり、それぞれScannerに与えて判定させます。例えばIkku::Reviewer#findに「ああ古池や蛙飛び込む水の音ああ」が渡されたとき、Reviewerは以下のパターンをつくってそれぞれScannerに判定させます。</p>
<pre><code>ああ古池や蛙飛び込む水の音ああ
　　古池や蛙飛び込む水の音ああ &lt;= これが一致する
　　　　や蛙飛び込む水の音ああ
　　　　　蛙飛び込む水の音ああ
　　　　　　飛び込む水の音ああ
　　　　　　　　　　水の音ああ
　　　　　　　　　　　の音ああ
　　　　　　　　　　　　音ああ
　　　　　　　　　　　　　ああ</code></pre><p>findでは一つ見つけた場合に処理を終えますが、searchではその後も処理を継続し、全てのパターンを探索します。find, searchでは「古池や蛙飛び込む水の音ああ」を表す配列が与えられた場合でも、五七五が取り出せた段階で成功ということになりますが、judgeでは完全に一句かどうか知りたいという要求があります。そのため、Scanner生成時に <code>exactly: true</code> というオプションが用意されており、judgeではこのオプションが利用されます。</p>
<h3 id="ikkunode">Ikku::Node</h3>
<p>一句ノードです。個々の形態素を表しています。MeCabから得られた品詞などの情報を簡単に扱えるように処理をラップしている他、<a href="http://ja.wikipedia.org/wiki/%E3%83%A2%E3%83%BC%E3%83%A9">モーラ</a>のような文節単位で音数を計算する処理なども担当しています。例えば古池は四音節、河童は三音節ということになり、これを五七五の計算に利用します。</p>
<p>また、自身が一句の先頭や末尾のノードとしてふさわしいかや、五・七・五の各句の先頭のノードとしてふさわしいかどうか、という情報を返す役割も担っています。例えば、接尾辞(-さ、-っぽい、-的など)を各フレーズの先頭に配置するのはふさわしくない、などです。</p>
<p>これらの細かなルールづくりの違いが、句を句として認識する際の差異に繋がります。この辺の個人によって趣向のことなる事柄については処理を分離し、Ikkuはあくまで静的に解析できる情報を提供するに留め、利用者が外部からルールベースを与えられるようにできると良いですね。</p>
<h2 id="おわり">おわり</h2>
<p><a href="https://github.com/r7kamura/ikku">r7kamura/ikku</a>という一句抽出ライブラリと、それを利用した<a href="https://github.com/r7kamura/ruboty-kokodeikku">r7kamura/ruboty-kokodeikku</a>という<a href="%5Br7kamura/ruboty%5D(https://github.com/r7kamura/ruboty)">Ruboty</a>用プラグインについて紹介しました。一晩でガッと書いたので雑な仕組みになってるとは思いますが、まあまあ動くし便利という感じにはなったかと思います。完璧な一句というものが存在しないように、完璧な判定器というものもまたアレなわけですので、各位Ikkuを参考に君だけの最強の判定器をつくっていきましょう。</p>
<h2 id="あわせて詠みたい">あわせて詠みたい</h2>
<p><a href="https://twitter.com/kokodeikku_bot">https://twitter.com/kokodeikku_bot</a></p>

  </div>
</article>

  </main>
</body>
</html>
