<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width">
  <title>Ruby on Rails on React on SSR on SPA</title>
  <link href="https://r7kamura.com/articles/2016-10-10-h" rel="canonical">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="search" type="application/opensearchdescription+xml" title="r7kamura.com" href="/opensearch.xml">
  <link rel="alternate" type="application/rss+xml" href="/feed.xml">
  
  <meta property="description" content="amakan での設計を例に、RailsでSingle-Page Applicationをつくるときの自分のやり方をまとめてみます。">
  <meta property="og:description" content="amakan での設計を例に、RailsでSingle-Page Applicationをつくるときの自分のやり方をまとめてみます。">
  
  <meta property="og:type" content="website">
  <meta property="og:title" content="Ruby on Rails on React on SSR on SPA">
  <meta property="og:url" content="https://r7kamura.com/articles/2016-10-10-h">
  
  <meta property="og:image" content="https://r7kamura.com/default_og_image.jpg">
  <meta property="twitter:card" content="summary">
  
</head>
<body>
  <header>
    <nav>
      <a href="/">r7kamura.com</a>
      <ul>
        <li>
          <a href="/articles">一覧</a>
        </li>
        <li>
          <a href="https://www.google.com/search?q=site:r7kamura.com">検索</a>
        </li>
      </ul>
    </nav>
  </header>
  <main>
    <article>
  <header>
    <time datetime="2016-10-10T00:00:00+00:00">2016年10月10日</time>
    <h1>Ruby on Rails on React on SSR on SPA</h1>
  </header>
  <div>
    <p><a href="https://amakan.net/">amakan</a> での設計を例に、RailsでSingle-Page Applicationをつくるときの自分のやり方をまとめてみます。</p>

<h2>Gem</h2>

<p>「JavaScriptで書かれたReactのコンポーネントからHTMLを生成する」というのをRubyでやるために、RubyのV8エンジン実装であるmini_racerというGemを使う。この処理を楽に実行するために、react_on_railsというGemも使う。</p>

<pre><code>gem "mini\_racer"gem "react\_on\_rails"
</code></pre>

<h2>View</h2>

<p>body要素内のHTMLは全てReactで生成するので、layout以外にviewのテンプレートは存在しない。</p>

<h2>Controller</h2>

<ol>
<li>初回リクエストの場合はHTMLを返す</li>
<li>ページ遷移時に呼ばれるリクエストの場合はJSONを返す</li>
<li>外部サイトからブラウザバックで戻ってきたときにJSONを見せない</li>
</ol>

<p>という要求に対応するため、<code>render</code> の代わりにこれをラップしたメソッドを使う。</p>

<pre><code>class ApplicationController \&lt; ActionController::Baseprivatedef action\_path"#{controller\_path}##{action\_name}"enddef common\_props { actionPath: action\_path, currentUser: current\_user, } enddef render\_for\_react(props: {}, status: 200) if request.format.json? response.headers["Cache-Control"] = "no-cache, no-store" response.headers["Expires"] = "Fri, 01 Jan 1990 00:00:00 GMT" response.headers["Pragma"] = "no-cache" render( json: common\_props.merge(props), status: status, ) else render( html: view\_context.react\_component( "Router", prerender: true, props: common\_props.merge(props).as\_json, ), layout: true, status: status, ) endendend
</code></pre>

<p>react_on_railsの提供しているhelperメソッド <code>react_component</code> を利用して、<code>Router</code> というReactのコンポーネントでHTMLを生成している。この部分でServer-Side Renderingしているということです。<code>prerender: true</code> というオプションを付けているので、RubyのV8エンジン実装を利用してHTMLが生成される。</p>

<p>以下は利用例。普段明示的あるいは省略して暗黙的に実行している、<code>render</code> の代わりに利用する。</p>

<pre><code>class UsersController \&lt; ApplicationControllerdef index render\_for\_react( props: { users: current\_community.users.order(:created\_at), }, ) enddef show render\_for\_react( props: { user: find\_user\_from\_request!, }, ) endend
</code></pre>

<h2>JavaScript</h2>

<p>react_on_railsの提供しているメソッド <code>react_component</code> は、まず予め設定しておいたパスに配置されたJavaScriptのファイルから、コンポーネントの定義を読み込んだ上で、指定された名前のコンポーネントを描画する。そのため、我々はJavaScriptのファイルを設置して、その中でコンポーネントを登録する必要がある。クライアントサイドとサーバサイドでは同じJavaScriptのコードを共用する。サーバサイドでは public/assets/main.js が読み込まれるように指定し、同時にこのファイルを配信してクライアントサイドからも利用する。</p>

<p>共用するJavaScriptコードのエントリポイントがこれ。</p>

<pre><code>// client/entry\_points/main.jsimport ReactOnRails from "react-on-rails";import Router from "../components/Router"; ReactOnRails.register({ Router });
</code></pre>

<p>実際にはwebpackを利用してコンパイルして public/assets/main.js に配置しているが、そこはどうでもいいので詳細は割愛する。react-on-railsというnpmのパッケージを利用して、ReactOnRailsというシングルトンにReactのコンポーネントを名前と共に登録している。さきほどコンポーネントを登録すると言っていた部分がこれ。ここで登録しておくと <code>react_component</code> で呼び出せるようになる。</p>

<h2>Router</h2>

<p>Routerコンポーネントの実装 (の一部)。actionPathを元に利用すべきComponentを選択しているだけ。つまりactionPathを変えれば画面が遷移する。リンクをクリックしたときに、XHRでサーバと通信してレスポンスをRouterのstateに入れれば、画面内に描画される要素が変わり、画面遷移が起きたということになる。</p>

<pre><code>import Categories from "../components/Categories";import Category from "../components/Category";import Community from "../components/Community";import User from "../components/User";// ...export default class Router extends React.Component { constructor(...args) {super(...args); this.state = { rootProps: this.props, }; } getComponent() {switch (this.state.rootProps.actionPath) {case "bookmarked\_topics#index": case "communities#show": case "unread\_topics#index": return Community; case "users#show": return User; case "categories#index": return Categories; case "categories#show": case "category\_archived\_topics#index": return Category; // ...}} render() {const Component = this.getComponent(); return \&lt;Component {...this.state.rootProps}/\&gt; }}
</code></pre>

<h2>Link</h2>

<p>リンクをクリックしたときに、XHRでサーバと通信してレスポンスをRouterのstateに入れたい。これを実現するために、全てのサイト内リンクについて、a要素の代わりに独自のコンポーネントを利用する。</p>

<pre><code>export default class Link extends React.Component {static contextTypes = { onLinkClick: React.PropTypes.func, } onClick(event) {this.context.onLinkClick(event); } render() {return( \&lt;a onClick={this.onClick.bind(this)} {...this.props}\&gt; {this.props.children} \&lt;/a\&gt; ); }}
</code></pre>

<p>これは利用例。</p>

<pre><code>\&lt;header className="header"\&gt; \&lt;Link href="/" className="header-logo"\&gt; megaboard \&lt;/Link\&gt; \&lt;/header\&gt;
</code></pre>

<p>Routerコンポーネントでcontext.onLinkClickを提供する。ついでに、以下の機能に対応しておく。</p>

<ul>
<li>ページ遷移中にプログレスバーを表示する</li>
<li>ページ遷移後にページ上部にスクロールする</li>
<li>pushState/popStateを利用してブラウザの履歴を調整する</li>
</ul>

<pre><code>import { sendGet } from "../lib/client-methods";import NProgress from "nprogress";export default class Router extends React.Component {static childContextTypes = { onLinkClick: React.PropTypes.func, } componentDidMount() {window.addEventListener("popstate", () =\&gt; {this.transitTo(document.location.href, { pushState: false }); }); } getChildContext() {return { onLinkClick: this.onLinkClick.bind(this), rootProps: this.state.rootProps, }; } onLinkClick(event) {if (!event.metaKey) {event.preventDefault(); const anchorElement = event.currentTarget.pathname ? event.currentTarget : event.currentTarget.querySelector("a"); this.transitTo(anchorElement.href, { pushState: true }); }} transitTo(url, { pushState }) { NProgress.start(); sendGet(url).then((rootProps) =\&gt; {if (pushState) { history.pushState({}, "", url); }this.setState({ rootProps }); }).then(() =\&gt; {window.scrollTo(0, 0); NProgress.done(); }).catch(() =\&gt; { NProgress.done(); }); }}
</code></pre>

<h2>title</h2>

<p>初回リクエストで返却するHTML内にtitle要素を含めつつ、ページ遷移時にもtitle要素を変更する必要がある。そして、title要素は個々のコンポーネントの中に定義したい。これには <a href="https://github.com/nfl/react-helmet/">react-helmet</a> を使う。</p>

<pre><code>import Helmet from "react-helmet";import React from "react";export default class TopPage extends React.Component { render() {return( \&lt;div\&gt; \&lt;Helmet title="Welcome"/\&gt; ... \&lt;/div\&gt; ); }}
</code></pre>

<p>こうしておくと、クライアントサイドではこのコンポーネントが描画されたタイミングでtitle要素を自動的に設定してくれるため、ページ遷移時にはtitle要素が上手く設定される。</p>

<p><code>global.Helmet</code> を用意しておくと、サーバサイドでもreact_on_railsの <code>server_render_js</code> を使って直近で描画されたtitle要素を取り出せるので、初回リクエストで返却するHTMLにはこれを使う。</p>

<pre><code>\&lt;!DOCTYPE html\&gt; \&lt;html\&gt; \&lt;head\&gt; \&lt;meta charset="utf-8"\&gt; \&lt;%= server\_render\_js("Helmet.rewind().title.toString()") %\&gt; \&lt;%= stylesheet\_link\_tag webpack\_asset\_url("main"), media: "all" %\&gt; \&lt;/head\&gt; \&lt;body\&gt; \&lt;%= yield %\&gt; \&lt;%= javascript\_include\_tag webpack\_asset\_url("main") %\&gt; \&lt;/body\&gt; \&lt;/html\&gt;
</code></pre>

<h2>デモ</h2>

<p>この設計で実装した <a href="https://amakan.net/">amakan.net</a> というサービスを公開しているので、あわよくば宣伝してください。</p>

<h2>おわり</h2>

<p>RailsでSingle-Page Applicationをつくるときの自分のやり方をまとめてみました。他の人がどう設計しているのかも気になるので、Single-Page Applicationを開発している人が居られましたら、是非記事を書いて知見を共有してください。</p>

<h2>あわせて読みたい</h2>

<p>RubyのモデルなどからJSONを生成するときの方法については、<a href="http://r7kamura.hatenablog.com/entry/2016/10/03/001212">モデルからJSON生成するときこうやってます2016 - ✘╹◡╹✘</a> で説明しているやり方でやっています。あとJavaScriptの話だと、<a href="http://r7kamura.hatenablog.com/entry/2016/10/04/060459">掲示板のJavaScriptこういう風に最適化しました - ✘╹◡╹✘</a> で説明しているやり方で最適化もしているので良ければどうぞ。</p>

  </div>
</article>

  </main>
</body>
</html>
