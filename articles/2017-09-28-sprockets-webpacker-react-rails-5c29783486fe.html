<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width">
  <title>SprocketsやWebpackerを使っていないアプリケーションでreact-railsを使う</title>
  <link href="/articles/2017-09-28-sprockets-webpacker-react-rails-5c29783486fe" rel="canonical">
  <link rel="stylesheet" href="/css/main.css">
  <meta property="og:type" content="article">
  <meta property="og:title" content="SprocketsやWebpackerを使っていないアプリケーションでreact-railsを使う">
  <meta property="og:url" content="https://r7kamura.com&#x2F;articles&#x2F;2017-09-28-sprockets-webpacker-react-rails-5c29783486fe">
  <meta property="twitter:card" content="summary">
  <meta property="twitter:title" content="SprocketsやWebpackerを使っていないアプリケーションでreact-railsを使う">
</head>
<body>
  <header>
    <nav>
      <a href="/">トップページ</a>
      <ul>
        <li>
          <a href="/articles">記事</a>
        </li>
        <li>
          <a href="https://google.com/search?q=site:r7kamura.com">検索</a>
        </li>
      </ul>
    </nav>
  </header>
  <main>
    <article>
  <h1>SprocketsやWebpackerを使っていないアプリケーションでreact-railsを使う</h1>
  <footer>
    <p>
      <time datetime="2017-09-28T00:00:00+09:00">2017年09月28日</time>
    </p>
  </footer>
  <div>
    <p>Rails プロジェクトにおいて「React を利用して Server-Side Rendering (SSR) をやるぞ」となった場合には、ライブラリの選択肢として以下の二つが筆頭に挙がることかと思われる。</p>
<ul>
<li>react_on_rails</li>
<li>react-rails</li>
</ul>
<p>react_on_rails では Browserify で bundle したコードを動作させるのには現時点では少し難があるため、現行のアプリケーションで Browserify を利用している場合、必然的に react-rails を選択することになるだろう。</p>
<p>さて、SSR を行う場合、サーバサイドのアプリケーションに JavaScript のファイルを読み込んでもらう必要がある訳だが、react-rails では、そのファイルの探索に Webpacker あるいは Sprockets を利用することを前提とした機能が提供されている。</p>
<p>そのため、それらの仕組みを使わずに自前で JavaScript のビルド方法を用意しているプロジェクトの場合、以下のようなクラスを用意し、Rails.configuration.react.server_renderer に設定する必要がある。</p>
<p>Rails.configuration.react.server_renderer = Class.new(React::ServerRendering::ExecJSRenderer) do  </p>
<h1 id="param-path-string"><a href="http://twitter.com/param" title="Twitter profile for @param">@param</a> path [String]</h1>
<p>  def initialize(path:)<br>    super(code: ::File.read(path))<br>  end</p>
<h1 id="param-component_name-string"><a href="http://twitter.com/param" title="Twitter profile for @param">@param</a> component_name [String]</h1>
<h1 id="param-props-hash"><a href="http://twitter.com/param" title="Twitter profile for @param">@param</a> props [Hash]</h1>
<h1 id="param-_prerender_options-boolean"><a href="http://twitter.com/param" title="Twitter profile for @param">@param</a> _prerender_options [Boolean]</h1>
<p>  def render(component_name, props, _prerender_options)<br>    super(component_name, props.to_json, {})<br>  end<br>end</p>
<p>react-rails は、SSR 用のコードが開発中に更新された場合に再読込するための仕組みとして、設定で指定されたファイルの編集日時が更新されていると server renderer のインスタンスを作り直すという仕組みを持っている。しかし、デフォルトで用意されているプレーンな (Sprockets や Webpacker に依存しない) server renderer である ExecJSRenderer では、コンストラクタの引数に JavaScript のコードの中身を直接渡す設計になっているため、この仕組みが上手く働かない。そのため、これを継承し、コンストラクタ内部でファイルを読み込むようなコードにする必要がある。</p>
<p>また、Sprockets 環境用に用意されている BundleRenderer とは違い、素の ExecJSRenderer では props を JSON 形式でエンコードされた文字列として渡す必要があるため、この部分もケアするように #render の実装を変更している。</p>

  </div>
</article>

  </main>
</body>
</html>
